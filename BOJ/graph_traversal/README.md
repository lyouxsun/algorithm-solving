# 그래프 탐색 : graph traversal

- 하나의 정점에서 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것

## 깊이 우선 탐색 : DFS (Depth-First Search)

- 루트 노드에서 시작하여 다음 노드로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
- 넓게 탐색하기 전에 **깊게** 탐색하는 것
- **모든 노드를 방문**하고자 할 때 사용하는 방법
- 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다. 안하면 무한루프에 빠질 수 있다.


- 구현 방법
    - 재귀 (자기자신 호출, 순환 알고리즘)
    - 스택
- 시간복잡도
    - DFS는 그래프(정점의 수: N, 간선의 수: E)의 모든 간선을 조회한다.
    - 인접 리스트로 표현된 그래프: O(N+E)
    - 인접 행렬로 표현된 그래프: O(N^2)

## 너비 우선 탐색 : BFS (Breadth-First Search)

- 루트 노드에서 시작하여 인접한 노드를 먼저 탐색하는 방법 (인접한 노드를 모두 방문한 후 )
- 깊게 탐색하기 전에 **넓게** 탐색하는 것
- DFS보다 좀 더 복잡
- 두 노드 사이의 **최단 경로** or **임의의 경로**를 찾고 싶을 때 사용하는 방법
    - 최단 경로 : 그래프 리스트에 해당 목적지까지 도달하는데 걸린 횟수를 저장 -> 그 중 최댓값 == 최단 경로
- 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다. 안하면 무한루프에 빠질 수 있다.


- 구현 방법
    - 큐
- 시간복잡도
    - 인접 리스트로 표현된 그래프: O(N+E)
    - 인접 행렬로 표현된 그래프: O(N^2)
    - 적은 수의 간선만 가지는 희소 그래프 (sparse graph)의 경우 인접 행렬보다 인접 리스트를 사용하는 것이 유리하다.

## DFS 🆚 BFS

- DFS가 BFS보다 좀 더 간단하다
- 검색 속도 : DFS > BFS (DFS가 더 느리다)

## 문제 풀이

| 번호 |    날짜    | 문제 번호     | 풀이법            | 주의사항                                                       | 새롭게 배운 내용                                                 | 다시 풀어보기 |
|:--:|:--------:|:----------|:---------------|:-----------------------------------------------------------|:----------------------------------------------------------|:-------:|
| 1  | 24.02.25 | BOJ 4963  | DFS - 재귀       | `sys.setrecursionlimit(10**6)`로 런타임 에러 (RecursionError) 해결 | 그래프 탐색 시 범위 제약 방법                                         |         |
| 2  | 24.02.26 | BOJ 10026 | DFS - 재귀       |                                                            | `dfs()` 함수 구현시 파라미터로 뭘 넘겨야 할까? (고민중🧐)                    |         |
| 3  | 24.02.28 | BOJ 2468  | DFS - 재귀       | `max({빈배열})` 을 호출하면 런타임 에러 (ValueError) 발생                 | 2차원 배열에서 최솟값, 최댓값 찾는 방법 (`min`, `max`, `map` 함수 사용)       |         |
| 4  | 24.03.01 | BOJ 11725 | BFS - 큐        | deque가 아닌 list를 사용하여 구현하면 시간초과가 나올 수 밖에 없다.                | deque 사용법                                                 |         |
| 5  | 24.03.02 | BOJ 7569  | BFS - 큐        | 3차원 list 다루기, 함수 정의할 때 기존에 사용중인 변수는 쓰지 맙시다! ^^             | 최단거리 구하는 방법 : 배열에 cnt를 저장하기                               |         |
| 6  | 24.03.05 | BOJ 14502 | BFS & DFS      | 함수 내에서 전역변수 사용법 : global 선언하기                              | DFS와 BFS를 모두 써야하는 어려운 문제ㅠ                                 |    ✅    |
| 7  | 24.03.08 | BOJ 7562  | BFS - 큐        | 예외 처리 주의 : (시작지점 == 목표지점) 일 때 고려하기                         | 최단경로 (BFS) 문제에서는 그래프/리스트 자체에 cnt 누적값을 저장                  |         |
| 8  | 24.03.10 | BOJ 11403 | 최단경로 - 플로이드 워셜 | 그래프 생성 시 **0**번째 인덱스부터 시작 🆚 문제에서는 **1**번 노드부터 있다고 취급      | 최단경로 알고리즘에는 `다익스트라`, `벨만포드`, `플로이드 워셜` 알고리즘이 있다.          |         |
| 9  | 24.03.10 | BOJ 11404 | 최단경로 - 플로이드 워셜 | `arr[i][i] = 0` 으로 초기화하는거 잊지 말자                            | 최단경로 알고리즘에서 최소비용 테이블의 모든 값을 **`float('inf')`** 로 초기화 해주자! |         |
| 10 | 24.03.11 | BOJ 2206  | BFS - 큐        |                                                            | 3차원 배열 선언 시 `[[[높이] 행 개수(세로)] 열 개수(가로)]` 로 선언해야 됨         |    ✅    |
| 11 | 24.03.14 | BOJ 2583  | BFS - 큐        | 문제에선 **함수 좌표** 제시 → 문제 풀 땐 **배열**좌표로 바꾸기 (x,y좌표 → 열, 행 좌표) |                                                           |         |
| 12 | 24.03.16 | BOJ 1987  | 백트래킹           | 행, 열, 높이 관련 변수명 정규화하기!!                                    | 시간 복잡도를 고려하여 list보단 set 사용하기                              |         |
| 13 | 24.03.18 | BOJ 14889 | 백트래킹           | for문의 루프 수를 최소화하여 시간초과를 방지하자                               | 절댓값 함수 `abs({값})` (import 필요X)                            |         |
| 14 | 24.08.22 | BOJ 16956 | BFS            | BFS보다 더 단순한 문제. 비어있는 모든 칸에 울타리를 설치하면 된다.                   | 문제에 '최소' 조건이 들어가지 않으면 더 단순하게 풀 수 있다.                      |         |

16637 브루트포스로 풀었는데 dfs로도 풀어보기!