# 그래프 탐색 : graph traversal

- 하나의 정점에서 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것

## 깊이 우선 탐색 : DFS (Depth-First Search)

- 루트 노드에서 시작하여 다음 노드로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
- 넓게 탐색하기 전에 **깊게** 탐색하는 것
- **모든 노드를 방문**하고자 할 때 사용하는 방법
- 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다. 안하면 무한루프에 빠질 수 있다.


- 구현 방법
    - 재귀 (자기자신 호출, 순환 알고리즘)
    - 스택
- 시간복잡도
    - DFS는 그래프(정점의 수: N, 간선의 수: E)의 모든 간선을 조회한다.
    - 인접 리스트로 표현된 그래프: O(N+E)
    - 인접 행렬로 표현된 그래프: O(N^2)

## 너비 우선 탐색 : BFS (Breadth-First Search)

- 루트 노드에서 시작하여 인접한 노드를 먼저 탐색하는 방법 (인접한 노드를 모두 방문한 후 )
- 깊게 탐색하기 전에 **넓게** 탐색하는 것
- DFS보다 좀 더 복잡
- 두 노드 사이의 **최단 경로** or **임의의 경로**를 찾고 싶을 때 사용하는 방법
    - 최단 경로 : 그래프 리스트에 해당 목적지까지 도달하는데 걸린 횟수를 저장 -> 그 중 최댓값 == 최단 경로
- 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다. 안하면 무한루프에 빠질 수 있다.


- 구현 방법
    - 큐
- 시간복잡도
    - 인접 리스트로 표현된 그래프: O(N+E)
    - 인접 행렬로 표현된 그래프: O(N^2)
    - 적은 수의 간선만 가지는 희소 그래프 (sparse graph)의 경우 인접 행렬보다 인접 리스트를 사용하는 것이 유리하다.

## DFS 🆚 BFS

- DFS가 BFS보다 좀 더 간단하다
- 검색 속도 : DFS > BFS (DFS가 더 느리다)

## 문제 풀이

| 번호 |    날짜    | 문제 번호                                              | 풀이법            | 주의사항                                                                                          | 새롭게 배운 내용                                                                             | 다시 풀어보기 |
|:--:|:--------:|:---------------------------------------------------|:---------------|:----------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------|:-------:|
| 1  | 24.02.25 | [BOJ 4963](https://www.acmicpc.net/problem/4963)   | DFS - 재귀       | `sys.setrecursionlimit(10**6)`로 런타임 에러 (RecursionError) 해결                                    | 그래프 탐색 시 범위 제약 방법                                                                     |         |
| 2  | 24.02.26 | [BOJ 10026](https://www.acmicpc.net/problem/10026) | DFS - 재귀       |                                                                                               | `dfs()` 함수 구현시 파라미터로 뭘 넘겨야 할까? (고민중🧐)                                                |         |
| 3  | 24.02.28 | [BOJ 2468](https://www.acmicpc.net/problem/2468)   | DFS - 재귀       | `max({빈배열})` 을 호출하면 런타임 에러 (ValueError) 발생                                                    | 2차원 배열에서 최솟값, 최댓값 찾는 방법 (`min`, `max`, `map` 함수 사용)                                   |         |
| 4  | 24.03.01 | [BOJ 11725](https://www.acmicpc.net/problem/11725) | BFS - 큐        | deque가 아닌 list를 사용하여 구현하면 시간초과가 나올 수 밖에 없다.                                                   | deque 사용법                                                                             |         |
| 5  | 24.03.02 | [BOJ 7569](https://www.acmicpc.net/problem/7569)   | BFS - 큐        | 3차원 list 다루기, 함수 정의할 때 기존에 사용중인 변수는 쓰지 맙시다! ^^                                                | 최단거리 구하는 방법 : 배열에 cnt를 저장하기                                                           |         |
| 6  | 24.03.05 | [BOJ 14502](https://www.acmicpc.net/problem/14502) | BFS & DFS      | 함수 내에서 전역변수 사용법 : global 선언하기                                                                 | DFS와 BFS를 모두 써야하는 어려운 문제ㅠ                                                             |    ✅    |
| 7  | 24.03.08 | [BOJ 7562](https://www.acmicpc.net/problem/7562)   | BFS - 큐        | 예외 처리 주의 : (시작지점 == 목표지점) 일 때 고려하기                                                            | 최단경로 (BFS) 문제에서는 그래프/리스트 자체에 cnt 누적값을 저장                                              |         |
| 8  | 24.03.10 | [BOJ 11403](https://www.acmicpc.net/problem/11403) | 최단경로 - 플로이드 워셜 | 그래프 생성 시 **0**번째 인덱스부터 시작 🆚 문제에서는 **1**번 노드부터 있다고 취급                                         | 최단경로 알고리즘에는 `다익스트라`, `벨만포드`, `플로이드 워셜` 알고리즘이 있다.                                      |         |
| 9  | 24.03.10 | [BOJ 11404](https://www.acmicpc.net/problem/11404) | 최단경로 - 플로이드 워셜 | `arr[i][i] = 0` 으로 초기화하는거 잊지 말자                                                               | 최단경로 알고리즘에서 최소비용 테이블의 모든 값을 **`float('inf')`** 로 초기화 해주자!                             |         |
| 10 | 24.03.11 | [BOJ 2206](https://www.acmicpc.net/problem/2206)   | BFS - 큐        |                                                                                               | 3차원 배열 선언 시 `[[[높이] 행 개수(세로)] 열 개수(가로)]` 로 선언해야 됨                                     |    ✅    |
| 11 | 24.03.14 | [BOJ 2583](https://www.acmicpc.net/problem/2583)   | BFS - 큐        | 문제에선 **함수 좌표** 제시 → 문제 풀 땐 **배열**좌표로 바꾸기 (x,y좌표 → 열, 행 좌표)                                    |                                                                                       |         |
| 12 | 24.03.16 | [BOJ 1987](https://www.acmicpc.net/problem/1987)   | 백트래킹           | 행, 열, 높이 관련 변수명 정규화하기!!                                                                       | 시간 복잡도를 고려하여 list보단 set 사용하기                                                          |         |
| 13 | 24.03.18 | [BOJ 14889](https://www.acmicpc.net/problem/14889) | 백트래킹           | for문의 루프 수를 최소화하여 시간초과를 방지하자                                                                  | 절댓값 함수 `abs({값})` (import 필요X)                                                        |         |
| 14 | 24.08.22 | [BOJ 16956](https://www.acmicpc.net/problem/16956) | BFS            | BFS보다 더 단순한 문제. 비어있는 모든 칸에 울타리를 설치하면 된다.                                                      | 문제에 '최소' 조건이 들어가지 않으면 더 단순하게 풀 수 있다.                                                  |         |
| 15 | 24.08.22 | [BOJ 5014](https://www.acmicpc.net/problem/5014)   | BFS            | BFS로 풀이 위해서 각 층에 방문하기 위한 최소 횟수를 저장하는 배열을 만듦                                                   | BFS는 1. deque에 남는게 없을 때까지 반복 & 2. 횟수를 저장X. 이전꺼+1 을 사용                                 |         |
| 16 | 24.08.23 | [BOJ 9376](https://www.acmicpc.net/problem/9376)   | BFS            | 2명이 탈출하는 경우 + 밖에서 들어오는 경우 -> 총 3가지 경우에서 횟수를 구한 다음에 이를 합해야한다.                                  | 문을 여는 것보다 문이 없는 부분을 우선처리 해야한다. (문 열 때에는 `append`, 문이 없을 때에는 `appendleft`)             |    ✅    |
| 17 | 24.08.24 | [BOJ 2251](https://www.acmicpc.net/problem/2251)   | BFS            | `sorted(arr)`는 정렬된 리스트를 반환하지만 arr를 바꾸진 않는다. 반면 `arr.sort()`는 arr를 바꾸지만 반환값은 없다.               | BFS는 반복문과 큐를 사용하기 때문에 주어진 정보(ex.물통들의 용량, 남은 물의 양)들을 리스트로 저장하는 것이 좋다.                  |         |
| 18 | 24.08.25 | [BOJ 16932](https://www.acmicpc.net/problem/16932) | BFS            | 0->1로 바꿀 때마다 그룹의 크기를 계산하면 시간초과 발생! 처음 주어진 배열에서 각 그룹의 크기를 미리 정해놓자!                             | 그룹의 크기를 계산할 때, 각 그룹에 순서대로 번호를 부여하고, 그 숫자로 그룹 위치를 표시한다. group의 크기는 별도의 리스트를 만든 후 저장한다. |         |
| 19 | 24.08.25 | [BOJ 17086](https://www.acmicpc.net/problem/17086) | BFS            | 그래프 탐색 문제에서는 모든 위치에서의 최단 거리를 계산하지 말고, 변하지 않는 것들(문제의 주어진 input)을 가지고 최소의 계산으로 문제를 푸는 방법을 찾아보자! | -> 이게 뭔 말인지 나도 잘 모르겠지만.. 아무튼 시간복잡도를 최소화하는 코드를 짜라는 뜻임!                                 |         |
| 20 | 24.08.26 | [BOJ 1600](https://www.acmicpc.net/problem/1600)   | BFS            | visited 한 칸에는 (지금까지 이동한 최단 경로 횟수)가 k+1개 저장해야 한다. => 3차원 배열ㄱㄱ!                                 | 이렇게 추가 제한 조건이 있을 때에는 {BFS + 3차원 배열}을 사용하자! (이 방법이 은근 많이 쓰이는 듯)                        |         |
| 21 | 24.08.26 | [BOJ 4991](https://www.acmicpc.net/problem/4991)   | BFS            | BFS+메모리제이션(DP) 인데,, 접근 방식에 따라서도 시간초과가 나는 까다로운 문제 (ꐦ°᷄▿°᷅)                                     | 문자열 리스트를 입력받을 때에는 반드시 줄바꿈문자 제거해줘야함! `.strip()`                                        |         |
| 22 | 24.08.27 | [BOJ 2151](https://www.acmicpc.net/problem/2151)   | BFS            | 이 문제의 핵심은 이동 방향에 따른 각 좌표의 최소 거울개수(cnt)를 배열에 저장하기! `visited`                                   | 참.. 어렵네요..ㅎ                                                                           |         |
| 23 | 24.08.27 | [BOJ 1914](https://www.acmicpc.net/problem/1914)   | DFS (재귀)       | 입력이 20 이상이면 과정 없이 결과만 출력해도 됨!! + 하노이탑의 답에는 규칙이 숨어있다!                                          | 문제를 작게 쪼갤 수 있을 때 재귀를 사용한다                                                             |         |
| 24 | 24.08.30 | [BOJ 17141](https://www.acmicpc.net/problem/17141) | BFS            | 2차원 배열에서 최단경로 구하는 방식을 사용해서 쉽게 풂                                                               | `deepcopy()` 는 시간도 오래걸리고 메모리도 많이 사용되니까 최대한 지양하자!                                      |         |
| 25 | 24.08.31 | [BOJ 17142](https://www.acmicpc.net/problem/17142) | BFS            | 비활성 바이러스는 뚫고 갈 수는 있지만 전파할 수는 없다! 이 부분을 처리하기가 어려워서 애를 먹었다ㅠ                                     | 백준에서는 numpy를 쓸수 없다..그리고 deepcopy 최소화하려고 방문 횟수를 저장하는 visited 배열을 사용함!                  |         |
| 26 | 24.09.01 | [BOJ 13549](https://www.acmicpc.net/problem/13549) | BFS            | 최단경로 -> BFS 사용하기! 근데 visited 배열을 곁들인..                                                        | 나의 지금 위치(me)가 목표(target)보다 idx가 작은 곳에 있는 경우만 고려하기! 그러려면 입력값 받자마자 분기문으로 처리~ㄱㄱ          |         |

16637 브루트포스로 풀었는데 dfs로도 풀어보기!