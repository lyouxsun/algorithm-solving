# 그래프 탐색 : graph traversal

- 하나의 정점에서 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것

### 그래프 문제 풀이법 요약

| 유형 번호 | 문제 유형               | 핵심 질문                      | 대표 알고리즘                            | 대표 예시 문제 또는 상황                   |
|:-----:|---------------------|----------------------------|------------------------------------|----------------------------------|
|  1️⃣  | **경로 탐색 / 존재 여부**   | "갈 수 있나?", "경로가 존재하나?"     | DFS, BFS 둘 다 가능                    | 미로 탈출 여부, 모든 경로 탐색, 싸이클 판별       |
|  2️⃣  | **최단 거리 / 최소 비용**   | "가장 빠르게 / 싸게 가는 방법은?"      | BFS (무가중치), 다익스트라, 벨만포드, 플로이드-워셜   | 미로 최소 칸 수, 도로 이동 최소 시간, 환율 사기 탐지 |
|  3️⃣  | **경로 수 / 방법의 수 세기** | "몇 가지 방법이 있나?", "경로 수는?"   | DFS + DP (Top-down), 위상정렬 + DP     | 내리막길, 파이프 옮기기, DAG 경로 수 구하기      |
|  4️⃣  | **구조 구성 / 연결성 판별**  | "이 구조가 가능한가?", "어떻게 구성할까?" | 유니온 파인드, MST(크루스칼/프림), 위상정렬, 이분 매칭 | 친구 네트워크, 작업 순서, 팀 구성, 이분 그래프 확인  |

## 깊이 우선 탐색 : DFS (Depth-First Search)

> visited 리스트를 통해 방문한 노드 확인하기!
>
> 재귀 함수는 종료 조건이 가장 중요!!

- 루트 노드에서 시작하여 다음 노드로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
- 넓게 탐색하기 전에 **깊게** 탐색하는 것
- **모든 노드를 방문**하고자 할 때 사용하는 방법
- 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다. 안하면 무한루프에 빠질 수 있다.


- 구현 방법
    - 재귀 (자기자신 호출, 순환 알고리즘)
    - 스택
- 시간복잡도
    - DFS는 그래프(정점의 수: N, 간선의 수: E)의 모든 간선을 조회한다.
    - 인접 리스트로 표현된 그래프: O(N+E)
    - 인접 행렬로 표현된 그래프: O(N^2)
- 예제 코드
```python
# ↑, ←, →, ↓ 방향으로 이동하기 위한 y, x 변화값
dy = [-1, 0, 0, 1]
dx = [0, -1, 1, 0]


# DFS 함수: 현재 위치 (y, x)에서 시작해서 도착지 (R-1, C-1)에 도달할 수 있는지 확인
def dfs(grid, y, x, visited):
  if (y, x) == (R - 1, C - 1):  # 도착 지점에 도달하면 True 반환
    return True

  visited[x][y] = True  # 현재 위치를 방문 처리 (※ x, y 순서 주의)

  for i in range(4):  # 상하좌우 4방향으로 이동 시도
    ny, nx = y + dy[i], x + dx[i]  # 다음 위치 계산
    if 0 <= ny < R and 0 <= nx < C:  # 범위 내에 있고
      if not visited[ny][nx] and grid[ny][nx] == 0:  # 방문하지 않았고 이동 가능한 곳(0이면 길)
        if dfs(grid, ny, nx, visited):  # 다음 위치에서 도달 가능하다면 True 반환
          return True
  return False  # 모든 경로를 다 가봤는데도 도달할 수 없으면 False

# DFS 탐색 시작 함수 (초기 세팅용)
def start_dfs(grid):
  visited = [[False] * C for _ in range(R)]  # 방문 여부를 저장할 2차원 배열
  return dfs(grid, 0, 0, visited)  # (0, 0)에서 시작
```

## 너비 우선 탐색 : BFS (Breadth-First Search)

- 루트 노드에서 시작하여 인접한 노드를 먼저 탐색하는 방법 (인접한 노드를 모두 방문한 후 )
- 깊게 탐색하기 전에 **넓게** 탐색하는 것
- DFS보다 좀 더 복잡
- 두 노드 사이의 **최단 경로** or **임의의 경로**를 찾고 싶을 때 사용하는 방법
    - 최단 경로 : 그래프 리스트에 해당 목적지까지 도달하는데 걸린 횟수를 저장 -> 그 중 최댓값 == 최단 경로
- 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다. 안하면 무한루프에 빠질 수 있다.


- 구현 방법
    - 큐
- 시간복잡도
    - 인접 리스트로 표현된 그래프: O(N+E)
    - 인접 행렬로 표현된 그래프: O(N^2)
    - 적은 수의 간선만 가지는 희소 그래프 (sparse graph)의 경우 인접 행렬보다 인접 리스트를 사용하는 것이 유리하다.

- 예제 코드
```python
from collections import deque  # BFS 구현을 위한 deque 사용

# ↑, ←, →, ↓ 방향으로 이동하기 위한 y, x 변화값
dy = [-1, 0, 0, 1]
dx = [0, -1, 1, 0]

# BFS 함수: (0, 0)에서 시작하여 (R-1, C-1)까지 도달 가능한지 여부 반환
def bfs(grid):
    visited = [[False] * C for _ in range(R)]  # 방문 여부를 저장하는 2차원 배열
    queue = deque()  # BFS 탐색용 큐
    queue.append((0, 0))  # 시작점 (0, 0) 삽입
    visited[0][0] = True  # 시작점 방문 처리

    while queue:
        y, x = queue.popleft()  # 현재 위치를 큐에서 꺼냄
        if (y, x) == (R - 1, C - 1):  # 도착지에 도달했으면 True 반환
            return True

        for i in range(4):  # 상하좌우 4방향 탐색
            ny, nx = y + dy[i], x + dx[i]  # 다음 위치 계산
            if 0 <= ny < R and 0 <= nx < C:  # 격자 범위 체크
                if not visited[ny][nx] and grid[ny][nx] == 0:  # 아직 방문하지 않았고 길(0)인 경우
                    visited[ny][nx] = True  # 방문 처리
                    queue.append((ny, nx))  # 다음 위치를 큐에 추가
                    
    return False  # 큐가 빌 때까지 도달하지 못하면 False 반환 (도달 불가)
```

## DFS 🆚 BFS

- DFS가 BFS보다 좀 더 간단하다
- 검색 속도 : DFS > BFS (DFS가 더 느리다)

## DFS + DP (Top-down)

| DFS+DP 적용 조건       | 설명                                        |
|--------------------|-------------------------------------------|
| 탐색 경로가 많다          | 모든 경로를 다 보면 지수 시간 소요                      |
| 동일한 상태로 여러 번 도달 가능 | 예: `(x, y)` 위치에서 도달하는 경우가 중복됨             |
| 결과를 저장하고 재활용할 수 있다 | 상태를 식별할 수 있는 `dp[x][y]` 같은 DP 테이블이 존재해야 함 |

```python
# 방향 벡터: 상, 하, 좌, 우
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

dp = [[-1 for _ in range(C)] for _ in range(R)]


# DFS 함수 정의: (x, y)에서 목적지까지 갈 수 있는 경로 수 반환
def dfs(y, x):
    # 1. 기저 조건 (종료 조건)을 만족하는 경우 재귀 종료 후 반환
    if is_base_case(state):
        return base_value(state)  # 보통 0 또는 1 반환

    # 2. 이미 계산된 경로 수가 있다면 그대로 반환 (메모이제이션, 중복 계산 방지)
    if dp[y][x] != -1:
        return dp[y][x]

    # 3. 처음 계산하는 경우 → 초기화
    dp[y][x] = 0  # 초기화 (아직 경로 없음)

    # 4. 현재 위치에서 이동 가능한 경로 계산 (재귀)
    for i in range(4):  # 4방향 탐색
        ny = y + dy[i]
        nx = x + dx[i]
        if 0 <= ny < R and 0 <= nx < C:     
            if (문제에서 지정한 경로의 조건):  # ex. 내리막길일 때만 이동
                # dp 배열 값 변경하기
                # 1. 더하기 (+) – 가능한 경로 수 / 경우의 수 누적 (ex. 몇 가지 방법이 있는지 세는 문제)
                dp[ny][nx] += dfs(ny, nx)
                # 2. 최댓값 / 최솟값 (max, min) – 최적 해 구하기 (ex. 여러 경로 중 최적의 결과를 선택해야 할 때 - 최대 or 최소)
                dp[ny][nx] = max(dp[y][x], dfs(ny, nx))
                # 3. 곱하기 (*) – 독립적인 선택의 경우의 수 조합 (ex. 분할 정복형 문제에서 두 부분이 독립적일 때)
                dp[ny][nx] *= dfs(ny, nx)

    return dp[y][x]  # 현재 위치에서 도달 가능한 전체 경로 수 반환
```

## 문제 풀이

| 번호 |    날짜    | 문제 번호                                              | 풀이법            | 주의사항                                                                                                              | 새롭게 배운 내용                                                                             | 다시 풀어보기 |
|:--:|:--------:|:---------------------------------------------------|:---------------|:------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------|:-------:|
| 1  | 24.02.25 | [BOJ 4963](https://www.acmicpc.net/problem/4963)   | DFS - 재귀       | `sys.setrecursionlimit(10**6)`로 런타임 에러 (RecursionError) 해결                                                        | 그래프 탐색 시 범위 제약 방법                                                                     |         |
| 2  | 24.02.26 | [BOJ 10026](https://www.acmicpc.net/problem/10026) | DFS - 재귀       |                                                                                                                   | `dfs()` 함수 구현시 파라미터로 뭘 넘겨야 할까? (고민중🧐)                                                |         |
| 3  | 24.02.28 | [BOJ 2468](https://www.acmicpc.net/problem/2468)   | DFS - 재귀       | `max({빈배열})` 을 호출하면 런타임 에러 (ValueError) 발생                                                                        | 2차원 배열에서 최솟값, 최댓값 찾는 방법 (`min`, `max`, `map` 함수 사용)                                   |         |
| 4  | 24.03.01 | [BOJ 11725](https://www.acmicpc.net/problem/11725) | BFS - 큐        | deque가 아닌 list를 사용하여 구현하면 시간초과가 나올 수 밖에 없다.                                                                       | deque 사용법                                                                             |         |
| 5  | 24.03.02 | [BOJ 7569](https://www.acmicpc.net/problem/7569)   | BFS - 큐        | 3차원 list 다루기, 함수 정의할 때 기존에 사용중인 변수는 쓰지 맙시다! ^^                                                                    | 최단거리 구하는 방법 : 배열에 cnt를 저장하기                                                           |         |
| 6  | 24.03.05 | [BOJ 14502](https://www.acmicpc.net/problem/14502) | BFS & DFS      | 함수 내에서 전역변수 사용법 : global 선언하기                                                                                     | DFS와 BFS를 모두 써야하는 어려운 문제ㅠ                                                             |    ✅    |
| 7  | 24.03.08 | [BOJ 7562](https://www.acmicpc.net/problem/7562)   | BFS - 큐        | 예외 처리 주의 : (시작지점 == 목표지점) 일 때 고려하기                                                                                | 최단경로 (BFS) 문제에서는 그래프/리스트 자체에 cnt 누적값을 저장                                              |         |
| 8  | 24.03.10 | [BOJ 11403](https://www.acmicpc.net/problem/11403) | 최단경로 - 플로이드 워셜 | 그래프 생성 시 **0**번째 인덱스부터 시작 🆚 문제에서는 **1**번 노드부터 있다고 취급                                                             | 최단경로 알고리즘에는 `다익스트라`, `벨만포드`, `플로이드 워셜` 알고리즘이 있다.                                      |         |
| 9  | 24.03.10 | [BOJ 11404](https://www.acmicpc.net/problem/11404) | 최단경로 - 플로이드 워셜 | `arr[i][i] = 0` 으로 초기화하는거 잊지 말자                                                                                   | 최단경로 알고리즘에서 최소비용 테이블의 모든 값을 **`float('inf')`** 로 초기화 해주자!                             |         |
| 10 | 24.03.11 | [BOJ 2206](https://www.acmicpc.net/problem/2206)   | BFS - 큐        |                                                                                                                   | 3차원 배열 선언 시 `[[[높이] 행 개수(세로)] 열 개수(가로)]` 로 선언해야 됨                                     |    ✅    |
| 11 | 24.03.14 | [BOJ 2583](https://www.acmicpc.net/problem/2583)   | BFS - 큐        | 문제에선 **함수 좌표** 제시 → 문제 풀 땐 **배열**좌표로 바꾸기 (x,y좌표 → 열, 행 좌표)                                                        |                                                                                       |         |
| 12 | 24.03.16 | [BOJ 1987](https://www.acmicpc.net/problem/1987)   | 백트래킹           | 행, 열, 높이 관련 변수명 정규화하기!!                                                                                           | 시간 복잡도를 고려하여 list보단 set 사용하기                                                          |         |
| 13 | 24.03.18 | [BOJ 14889](https://www.acmicpc.net/problem/14889) | 백트래킹           | for문의 루프 수를 최소화하여 시간초과를 방지하자                                                                                      | 절댓값 함수 `abs({값})` (import 필요X)                                                        |         |
| 14 | 24.08.22 | [BOJ 16956](https://www.acmicpc.net/problem/16956) | BFS            | BFS보다 더 단순한 문제. 비어있는 모든 칸에 울타리를 설치하면 된다.                                                                          | 문제에 '최소' 조건이 들어가지 않으면 더 단순하게 풀 수 있다.                                                  |         |
| 15 | 24.08.22 | [BOJ 5014](https://www.acmicpc.net/problem/5014)   | BFS            | BFS로 풀이 위해서 각 층에 방문하기 위한 최소 횟수를 저장하는 배열을 만듦                                                                       | BFS는 1. deque에 남는게 없을 때까지 반복 & 2. 횟수를 저장X. 이전꺼+1 을 사용                                 |         |
| 16 | 24.08.23 | [BOJ 9376](https://www.acmicpc.net/problem/9376)   | BFS            | 2명이 탈출하는 경우 + 밖에서 들어오는 경우 -> 총 3가지 경우에서 횟수를 구한 다음에 이를 합해야한다.                                                      | 문을 여는 것보다 문이 없는 부분을 우선처리 해야한다. (문 열 때에는 `append`, 문이 없을 때에는 `appendleft`)             |    ✅    |
| 17 | 24.08.24 | [BOJ 2251](https://www.acmicpc.net/problem/2251)   | BFS            | `sorted(arr)`는 정렬된 리스트를 반환하지만 arr를 바꾸진 않는다. 반면 `arr.sort()`는 arr를 바꾸지만 반환값은 없다.                                   | BFS는 반복문과 큐를 사용하기 때문에 주어진 정보(ex.물통들의 용량, 남은 물의 양)들을 리스트로 저장하는 것이 좋다.                  |         |
| 18 | 24.08.25 | [BOJ 16932](https://www.acmicpc.net/problem/16932) | BFS            | 0->1로 바꿀 때마다 그룹의 크기를 계산하면 시간초과 발생! 처음 주어진 배열에서 각 그룹의 크기를 미리 정해놓자!                                                 | 그룹의 크기를 계산할 때, 각 그룹에 순서대로 번호를 부여하고, 그 숫자로 그룹 위치를 표시한다. group의 크기는 별도의 리스트를 만든 후 저장한다. |         |
| 19 | 24.08.25 | [BOJ 17086](https://www.acmicpc.net/problem/17086) | BFS            | 그래프 탐색 문제에서는 모든 위치에서의 최단 거리를 계산하지 말고, 변하지 않는 것들(문제의 주어진 input)을 가지고 최소의 계산으로 문제를 푸는 방법을 찾아보자!                     | -> 이게 뭔 말인지 나도 잘 모르겠지만.. 아무튼 시간복잡도를 최소화하는 코드를 짜라는 뜻임!                                 |         |
| 20 | 24.08.26 | [BOJ 1600](https://www.acmicpc.net/problem/1600)   | BFS            | visited 한 칸에는 (지금까지 이동한 최단 경로 횟수)가 k+1개 저장해야 한다. => 3차원 배열ㄱㄱ!                                                     | 이렇게 추가 제한 조건이 있을 때에는 {BFS + 3차원 배열}을 사용하자! (이 방법이 은근 많이 쓰이는 듯)                        |         |
| 21 | 24.08.26 | [BOJ 4991](https://www.acmicpc.net/problem/4991)   | BFS            | BFS+메모리제이션(DP) 인데,, 접근 방식에 따라서도 시간초과가 나는 까다로운 문제 (ꐦ°᷄▿°᷅)                                                         | 문자열 리스트를 입력받을 때에는 반드시 줄바꿈문자 제거해줘야함! `.strip()`                                        |         |
| 22 | 24.08.27 | [BOJ 2151](https://www.acmicpc.net/problem/2151)   | BFS            | 이 문제의 핵심은 이동 방향에 따른 각 좌표의 최소 거울개수(cnt)를 배열에 저장하기! `visited`                                                       | 참.. 어렵네요..ㅎ                                                                           |         |
| 23 | 24.08.27 | [BOJ 1914](https://www.acmicpc.net/problem/1914)   | DFS (재귀)       | 입력이 20 이상이면 과정 없이 결과만 출력해도 됨!! + 하노이탑의 답에는 규칙이 숨어있다!                                                              | 문제를 작게 쪼갤 수 있을 때 재귀를 사용한다                                                             |         |
| 24 | 24.08.30 | [BOJ 17141](https://www.acmicpc.net/problem/17141) | BFS            | 2차원 배열에서 최단경로 구하는 방식을 사용해서 쉽게 풂                                                                                   | `deepcopy()` 는 시간도 오래걸리고 메모리도 많이 사용되니까 최대한 지양하자!                                      |         |
| 25 | 24.08.31 | [BOJ 17142](https://www.acmicpc.net/problem/17142) | BFS            | 비활성 바이러스는 뚫고 갈 수는 있지만 전파할 수는 없다! 이 부분을 처리하기가 어려워서 애를 먹었다ㅠ                                                         | 백준에서는 numpy를 쓸수 없다..그리고 deepcopy 최소화하려고 방문 횟수를 저장하는 visited 배열을 사용함!                  |         |
| 26 | 24.09.01 | [BOJ 13549](https://www.acmicpc.net/problem/13549) | BFS            | 최단경로 -> BFS 사용하기! 근데 visited 배열을 곁들인..                                                                            | 나의 지금 위치(me)가 목표(target)보다 idx가 작은 곳에 있는 경우만 고려하기! 그러려면 입력값 받자마자 분기문으로 처리~ㄱㄱ          |         |
| 27 | 24.09.02 | [BOJ 2234](https://www.acmicpc.net/problem/2234)   | BFS            | 요소 개수, 크기 구하는 문제는 BFS~ 마지막에 이어진 두 요소의 크기 합을 구할 때, r-1이랑 c-1까지만 탐색하려고 했다가 오류 발생 (전범위 다 다룰 수 있어야 한다!)               | [비스마스킹 연산](../../../algorithm-solving/python/bit_masking.md)                          |         |
| 28 | 24.10.17 | [BOJ 3184](https://www.acmicpc.net/problem/3184)   | BFS            | 각 영역마다 bfs를 실행하여 남은 동물의 수를 구함                                                                                     | 영역 = 울타리 내에서 이동 가능한 모든 범위                                                             |         |
| 29 | 24.10.18 | [BOJ 1926](https://www.acmicpc.net/problem/1926)   | BFS            | 2차원 배열에서 그래프 묶음의 수, 최대 그래프의 크기 구할 때는 BFS~                                                                         |                                                                                       |         |
| 30 | 24.10.26 | [BOJ 10451](https://www.acmicpc.net/problem/10451) | BFS            | 그래프 요소의 개수 구할 때에도 BFS~                                                                                            |                                                                                       |         |
| 31 | 24.11.03 | [BOJ 2636](https://www.acmicpc.net/problem/2636)   | BFS            | 발상의 전환! 치즈가 아닌 것들에 집중하자~                                                                                          | q 에는 공기 좌표를 집어넣고, cheese 리스트에는 치즈 좌표를 집어넣어서 따로 계산하는게 신기하다!                            |         |
| 32 | 25.01.02 | [BOJ 17144](https://www.acmicpc.net/problem/17144) | BFS            | 사실 BFS 보다는 구현에 가까웠지만, 그 안에 BFS가 중요한 로직을 담당함.                                                                      | 2차원 배열의 값을 순환시킬 때 indexError에 주의하자!! 이번에는 r, c를 혼동해서 사용했다가 오류가 남.                     |         |
| 33 | 25.01.03 | [BOJ 1967](https://www.acmicpc.net/problem/1967)   | DFS            | 가장 **먼 거리**에 있는 두 노드 구하는 방법 = DFS!!                                                                               | 1. 루트 노드에서 가장 먼 노드를 찾기<br>2. 그 노드와 가장 멀리 떨어진 노드 ⇒ 답                                   |    ✅    |
| 34 | 25.01.06 | [BOJ 1707](https://www.acmicpc.net/problem/1707)   | DFS (재귀)       | 이분 그래프인지 확인하는 방법 : 지금 노드가 0이면 그 점에서 탐색한 다음 노드는 1 (지금이 1이면 다음 노드는 0) 이런 식으로 탐색해나가기!                                | 이분 그래프 : 그래프의 정점을 둘로 분할할 때, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분해할 수 있는 그래프                   |         |
| 35 | 25.01.07 | [BOJ 14442](https://www.acmicpc.net/problem/14442) | BFS (w.3차원 배열) | 3차원 배열 생성 = `[[[0 for _ in range(col)] for _ in range(row)] for _ in range(depth)]`<br>3차원 배열 조회 = `arr[층][행][열]` | BFS에서 경로말고 또 하나를 카운트해야 한다면 3차원 배열의 depth를 통해 카운트한다. (이 문제에서는 **부순 벽의 개수** 카운트)        |         |
| 36 | 25.01.08 | [BOJ 16933](https://www.acmicpc.net/problem/16933) | BFS (w.3차원 배열) | 최단 경로의 횟수가 홀수이면 벽을 부술 수 있다는 점을 이용하면 14442번 문제에서 변수를 추가하지 않고도 풀 수 있다!                                              |                                                                                       |         |
| 37 | 25.01.14 | [BOJ 20208](https://www.acmicpc.net/problem/20208) | 백트래킹           | 모든 경우를 탐색하고 싶은데, 그 중에서 조건을 만족할 수 없는 경우는 바로바로 쳐내서 시간을 단축하는 경우 → 백트래킹을 사용해보자!!                                      | 방문 확인 배열을 재귀함수 안에서 바꿔주면 모든 경우를 탐색할 수 없다!! 재귀함수 호출 전에 바꾸기!! (호출 후에는 또 원복해야함)           |         |
| 38 | 25.01.15 | [BOJ 25825](https://www.acmicpc.net/problem/25825) | 백트래킹           | 같은 집단 내의 원소 구할 때 a, b 변수 선언을 잘못해서 많이 헤맸다ㅠ                                                                         | 백트래킹에서 재귀함수 정의할 때, 각 단계에서 어디까지 계산하고 넘겨줄지 명확하게 정하는 것이 가장 중요하다!!!                       |         |
| 39 | 25.01.16 | [BOJ 9663](https://www.acmicpc.net/problem/9663)   | 백트래킹           | 백트래킹 마스터^^                                                                                                        | 한 행에 하나의 퀸만 올 수 있다 → 방문 처리는 밑의 행에만 하면 된다. 이미 지나온 행까지 방문처리 할 필요가 없음.                   |         |
| 40 | 25.06.26 | [BOJ 16928](https://www.acmicpc.net/problem/16928) | BFS            | 가중치가 동일한 그래프에서 최단 경로를 구할 때에는 BFS를 쓰자!!!                                                                           | 방문 처리 배열 활용하는거 까먹지 마라~~                                                               |         |
| 41 | 25.06.26 | [BOJ 16234](https://www.acmicpc.net/problem/16234) | BFS            | BFS 방문 처리 시점 & 큐에 넣는 시점 잘 생각하기! (매번 여기서 틀리는 것 같음)                                                                 | 이 문제는 모든 노드를 확인해야 하는 문제여서 이중 for 문 안에서 bfs를 실행해야 한다. (아닌 BFS 문제도 있음)                  |         |
| 42 | 25.06.28 | [BOJ 14938](https://www.acmicpc.net/problem/14938) | 최단경로 - 다익스트라   | 다익스트라 = 인접행렬 + 힙                                                                                                  | 최단경로가 갱신될 때마다 힙에 넣기 & 힙에 넣은 애들만 탐색하면 됨!! (모든 노드를 방문했는지 여부를 확인할 필요X)                   |         |
| 43 | 25.06.29 | [BOJ 1167](https://www.acmicpc.net/problem/1167)   | 다익스트라 / DFS+DP | 다익스트라로 해도 되지만 시간초과 발생. DFS + DP (메모이제이션) 방식이 정석 풀이                                                                |                                                                                       |         |
| 44 | 25.06.30 | [BOJ 1937](https://www.acmicpc.net/problem/1937)   | DFS + DP       | 모든 노드를 시작으로 DFS를 하면 시간초과 → DP 테이블을 통한 메모이제이션을 통해 중복연산 제거                                                          | 간선 가중치 or 노드의 합이 최대가 되는 경로 찾을 때에는 DFS + DP 방식 사용하기!!!                                 |         |
| 45 | 25.07.02 | [BOJ 1520](https://www.acmicpc.net/problem/1520)   | DFS + DP       | 4개의 방향에 대해서 모두 재귀를 진행할 경우 시간복잡도는 `O(4^(R*C))` 가 된다. 이 때 DP(메모이제이션)을 사용해야 한다!!!                                    | 재귀 문제풀이에서 Pypy3로 채점하면 메모리 초과 오류가 발생한다! 반드시 Python3 로 채점 해야 됨                          |         |

16637 브루트포스로 풀었는데 DFS로도 풀어보기!

- 1967번 보충 설명
    - 루트 노드에서 가장 멀리 떨어진 노드 = 트리 지름의 끝점 중 하나
    - 나는 '2개의 끝점이 모두 리프 노드이다.' 까지만 생각했지만, **'루트 노드에서 멀리 떨어진 노드는 무조건 트리의 지름을 이루는 점 중 하나이다.'** 를 간과했다..

      (루트에서 가장 먼 노드를 u라고 하자. 만약 u가 지름의 끝점이 아니라면, 트리의 지름 경로는 u보다 더 멀리 떨어진 다른 노드를 포함해야 한다.
      하지만 u는 루트에서 가장 멀리 떨어진 노드이기 때문에 u보다 더 먼 노드는 존재할 수 없다. 따라서 u는 반드시 지름의 끝점 중 하나가 된다.)
    - u에서 가장 멀리 떨어진 노드 = 지름의 다른 끝점
    - bfs가 많이 부족하다. 더 연습해야겠다!