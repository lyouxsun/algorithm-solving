# DP : dynamic programming

- 여러 개의 문제로 나누어 푸는 방법
- 메모리를 활용하여 수행시간을 최소화한다.

  = 이미 계산된 결과 (작은 문제)는 별도의 메모리 영역(배열, DP테이블)에 저장하여 **다시는 계산하지 않도록 한다.** = 캐싱!!!
- top down, bottom up 모두 작은 문제의 답을 캐싱하여 큰 문제를 푸는데 활용한다는 점은 동일하다.

### top down

- 하향식, 위에서부터 아래로 내려가는 방식
- 메모이제이션 : 이전에 계산된 결과를 기록하여 사용하는 기법
- ex) 피보나치 수열 문제 : 재귀함수로 구현 (큰 문제부터 시작해서 점차 작은 문제로 접근한다)

```python

dp = [0] * 100


def fibo(x):
    if x == 1 or x == 2:
        return 1
    if dp[x] != 0:
        return dp[x]
    dp[x] = fibo(x - 1) + fibo(x - 2)
    return dp[x]


print(fibo(99))

```

### bottom up

- 상향식, DP의 전형적인 형태
- ex) 피보나치 수열 문제 : 반복문으로 구현, 작은 문제들을 모두 해결해 놓은 후에, 이를 활용하여 큰 문제를 해결한다.

  f(n) 까지 모두 미리 계산하여 DP테이블에 저장해 놓은 후에, 큰 문제를 차례대로 구현해나간다. -> 중복을 최소화

```python

dp = [0] * 100

dp[1] = 1
dp[2] = 1

for i in range(3, 100):
    dp[i] = dp[i - 1] + dp[i - 2]

print(dp[99])

```

- 언제 사용할까?
    - 최적 부분 구조 : 큰 문제를 작은 문제로 나눌 수 있고, 작은 문제의 답을 모아 큰 문제를 해결할 수 있는 경우
    - 중복되는 부분 문제 : 동일한 작은 문제를 반복적으로 해결해야 하는 경우

- 문제 푸는 방법
    1. 문제 탐색하기
    2. **점화식 세우기 : 인접한 항들 사이의 관계식**
    3. 검증 및 구현 : DP 식이 잘 들어맞는지, 시간 복잡도가 괜찮은지 확인해야 한다.

ex. 피보나치 수열

## 문제 풀이

| 번호 |    날짜    | 문제 번호                                              | 풀이법                                                                    | 주의사항                                                                      | 새롭게 배운 내용                                                        | 다시 풀어보기 |
|:--:|:--------:|:---------------------------------------------------|:-----------------------------------------------------------------------|:--------------------------------------------------------------------------|:-----------------------------------------------------------------|:-------:|
| 1  | 24.07.22 | [BOJ 11722](https://www.acmicpc.net/problem/11722) | arr[i] 를 포함하는 감소하는 수열의 최대길이 찾아서 dp테이블에 저장 -> 감소수열을 이어 나가기!             |                                                                           | dp 풀이법 익히는중;;                                                    |         |
| 2  | 24.07.22 | [BOJ 11055](https://www.acmicpc.net/problem/11055) | arr[i] 를 포함하는 증가하는 수열 중 합의 최댓값을 찾아서 dp테이블에 저장 -> 증가수열을 이어 나가기!         |                                                                           | dp 풀이법 익히는중;                                                     |         |
| 3  | 24.07.22 | [BOJ 11054](https://www.acmicpc.net/problem/11054) | arr[0]~arr[i] 에서 증가하는 수열 중 최대길이 + arr[i]~arr[N-1] 에서 감소하는 수열 중 최대길이 -1 | dp1, dp2 모두 arr[i]를 포함하니까 답은 -1을 해줘야한다!                                   | 1, 2번 문제와 같이 풀어서 풀이법을 생각해 낼 수 있었던 것 같다                           |         |
| 4  | 24.07.23 | [BOJ 14002](https://www.acmicpc.net/problem/14002) | 부분 수열을 만들 때, 자신의 이전 순서가 되는 숫자의 인덱스를 저장하는 dp 테이블을 하나 더 추가!!             |                                                                           |                                                                  |         |
| 5  | 24.07.24 | [BOJ 11048](https://www.acmicpc.net/problem/11048) | BFS에서 최단경로를 구하는 방식과 동일하게 풂. `arr[i][j] += 주변 값들 중 최댓값`                 | dp 테이블이 따로 필요하지 않음!                                                       | dp = 한번 오른쪽/아래쪽 으로 가면 다시 올라갈 수 없음 = 문제가 점점 작아진다.                 |
| 6  | 24.07.25 | [BOJ 11060](https://www.acmicpc.net/problem/11060) | `dp[i] = arr[i] 까지 오는데 걸리는 최소 점프 수`                                    |                                                                           | 바텀업 : 0부터 시작해서 for문, 탑다운 : n(맨끝)부터 시작해서 재귀                       |
| 7  | 24.07.25 | [BOJ 15486](https://www.acmicpc.net/problem/15486) | i = 0 ~ n-1 을 돌며, i번째 상담을 하는 경우 & 하지 않는 경우를 고려                         | input 개수가 많기 때문에 시간복잡도가 O(n<sup>2</sup>) 이상이면 안된다!                        | [파이썬  빠른입출력 필수!!](https://www.acmicpc.net/board/view/22716)      |    ✅    |
| 7  | 24.07.26 | [BOJ 10942](https://www.acmicpc.net/problem/10942) | 시작 인덱스 :i, 끝 인덱스 : j 인 수열이 팰린드롬이면 dp[i][j]에 1, 아니면 0을 저장               | 재귀(topdown)로 구현하면 메모리 초과가 발생해서 바텀업으로 제출                                   |                                                                  |    ✅    |
| 8  | 24.07.26 | [BOJ 9095](https://www.acmicpc.net/problem/9095)   | 1부터 차례대로 구해보니 규칙(점화식)이 보여서 풂. 풀이의 정확한 이유는 모르겠음 -> 유레카!!                |                                                                           |                                                                  |         |
| 9  | 24.07.27 | [BOJ 15989](https://www.acmicpc.net/problem/15989) | dp 테이블 = 이전 수에서 1만 더해서 만들 수 있는 방법 수 + 2만 더해서 + 3만 더해서 만들 수 있는 방법 수     |                                                                           | 이런 생각을 어떻게 하는거지.. 아직 멀었다ㅠ                                        |    ✅    |
| 10 | 24.07.28 | [BOJ 11066](https://www.acmicpc.net/problem/11066) | 실패.. 실버 5부터 매일 한 문제씩 풀며 실력 키워서 다시 도전한다!!!!                             |                                                                           |                                                                  |    ✅    |
| 11 | 24.07.28 | [BOJ 12865](https://www.acmicpc.net/problem/12865) | dp[i][j] = i번째 물품까지 고려한 상황에서, 무게가 j 일 때 가치의 최대합                        |                                                                           | 진짜 어떻게 이런 아이디어가 나오지..? dp 진짜 어렵다ㅠ                                |    ✅    |
| 12 | 24.07.30 | [BOJ 11052](https://www.acmicpc.net/problem/11052) | 구하고자 하는 것 : dp[i] = i개 카드를 구매할 때, 가격의 최댓값                              |                                                                           | 1번 인덱스부터 입력받는 방법 : `arr = [0] + list(map(int, input().split()))` |         |
| 13 | 24.08.12 | [BOJ 17069](https://www.acmicpc.net/problem/17069) | 3개의 dp 테이블을 사용. 각각 수직, 수평, 대각선으로 i, j에 도착하는 방법을 dp_?[i][j]에 저장         | dp 테이블 3개 만들 생각을 어떻게 하는걸까.. 그리고 3차원 배열로 하려다 다루기 너무 어려워서 서로 다른 3개의 배열을 만듦. |                                                                  |         |
| 14 | 24.10.15 | [BOJ 17626](https://www.acmicpc.net/problem/17626) | `dp[n] = min(dp[n], dp[n-제곱수]+1)` 점화식 세워서 품!                           | 처음 dp테이블은 최댓값인 4로 초기화함                                                    | dp 어렵다.. 시험기간동안 마스터해야지!!                                         |         |
| 15 | 24.10.27 | [BOJ 10826](https://www.acmicpc.net/problem/10826) | 바텀업 방식으로 dp 테이블을 모두 채운 후에 원하는 인덱스 값(=답) 출력                             |                                                                           |                                                                  |         |
| 16 | 24.10.31 | [BOJ 11057](https://www.acmicpc.net/problem/11057) | n개의 자리 수마다 0~9가 일의 자리에 오는 숫자의 개수 → 규칙이 존재한다!                           |                                                                           | 아니.. 저 풀이법을 어떻게 생각해내요ㅠㅠ 될 때까지 하면 되지~~                            |    ✅    |
| 17 | 24.11.04 | [BOJ 2293](https://www.acmicpc.net/problem/2293)   | 동전 1개만 사용한 경우 -> 2개 사용 -> 3개 사용 -> ..  이 순서대로 dp 테이블 갱신해나가기            | 인덱스 에러가 나지 않도록 n번째 동전은 dp[coins[n]] 부터 갱신해 나가기!                           | 맨 처음에 dp 테이블을 1로 초기화하는 건 `dp[coin] += 1` 만 하면 됨. (자기자신만 1 더해주기)  |         |

- DP 개념 설명 : https://www.youtube.com/watch?v=5Lu34WIx2Us&t=2120s
- DP문제 추천 : https://stonejjun.tistory.com/24
