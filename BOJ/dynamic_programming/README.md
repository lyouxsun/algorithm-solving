# DP : dynamic programming

- 여러 개의 문제로 나누어 푸는 방법
- 메모리를 활용하여 수행시간을 최소화한다.

  = 이미 계산된 결과 (작은 문제)는 별도의 메모리 영역(배열, DP테이블)에 저장하여 **다시는 계산하지 않도록 한다.** = 캐싱!!!
- top down, bottom up 모두 작은 문제의 답을 캐싱하여 큰 문제를 푸는데 활용한다는 점은 동일하다.

### top down

- 하향식, 위에서부터 아래로 내려가는 방식
- 메모이제이션 : 이전에 계산된 결과를 기록하여 사용하는 기법
- ex) 피보나치 수열 문제 : 재귀함수로 구현 (큰 문제부터 시작해서 점차 작은 문제로 접근한다)

```python

dp = [0] * 100


def fibo(x):
    if x == 1 or x == 2:
        return 1
    if dp[x] != 0:
        return dp[x]
    dp[x] = fibo(x - 1) + fibo(x - 2)
    return dp[x]


print(fibo(99))

```

### bottom up

- 상향식, DP의 전형적인 형태
- ex) 피보나치 수열 문제 : 반복문으로 구현, 작은 문제들을 모두 해결해 놓은 후에, 이를 활용하여 큰 문제를 해결한다.

  f(n) 까지 모두 미리 계산하여 DP테이블에 저장해 놓은 후에, 큰 문제를 차례대로 구현해나간다. -> 중복을 최소화

```python

dp = [0] * 100

dp[1] = 1
dp[2] = 1

for i in range(3, 100):
    dp[i] = dp[i - 1] + dp[i - 2]

print(dp[99])

```

- 언제 사용할까?
    - 최적 부분 구조 : 큰 문제를 작은 문제로 나눌 수 있고, 작은 문제의 답을 모아 큰 문제를 해결할 수 있는 경우
    - 중복되는 부분 문제 : 동일한 작은 문제를 반복적으로 해결해야 하는 경우

- 문제 푸는 방법
    1. 문제 탐색하기
    2. **점화식 세우기 : 인접한 항들 사이의 관계식**
    3. 검증 및 구현 : DP 식이 잘 들어맞는지, 시간 복잡도가 괜찮은지 확인해야 한다.

ex. 피보나치 수열

## 문제 풀이

| 번호 |    날짜    | 문제 번호                                              | 풀이법                                                                    | 주의사항                                               | 새롭게 배운 내용                                                   | 다시 풀어보기 |
|:--:|:--------:|:---------------------------------------------------|:-----------------------------------------------------------------------|:---------------------------------------------------|:------------------------------------------------------------|:-------:|
| 1  | 24.07.22 | [BOJ 11722](https://www.acmicpc.net/problem/11722) | arr[i] 를 포함하는 감소하는 수열의 최대길이 찾아서 dp테이블에 저장 -> 감소수열을 이어 나가기!             |                                                    | dp 풀이법 익히는중;;                                               |         |
| 2  | 24.07.22 | [BOJ 11055](https://www.acmicpc.net/problem/11055) | arr[i] 를 포함하는 증가하는 수열 중 합의 최댓값을 찾아서 dp테이블에 저장 -> 증가수열을 이어 나가기!         |                                                    | dp 풀이법 익히는중;                                                |         |
| 3  | 24.07.22 | [BOJ 11054](https://www.acmicpc.net/problem/11054) | arr[0]~arr[i] 에서 증가하는 수열 중 최대길이 + arr[i]~arr[N-1] 에서 감소하는 수열 중 최대길이 -1 | dp1, dp2 모두 arr[i]를 포함하니까 답은 -1을 해줘야한다!            | 1, 2번 문제와 같이 풀어서 풀이법을 생각해 낼 수 있었던 것 같다                      |         |
| 4  | 24.07.23 | [BOJ 14002](https://www.acmicpc.net/problem/14002) | 부분 수열을 만들 때, 자신의 이전 순서가 되는 숫자의 인덱스를 저장하는 dp 테이블을 하나 더 추가!!             |                                                    |                                                             |         |
| 5  | 24.07.24 | [BOJ 11048](https://www.acmicpc.net/problem/11048) | BFS에서 최단경로를 구하는 방식과 동일하게 풂. `arr[i][j] += 주변 값들 중 최댓값`                 | dp 테이블이 따로 필요하지 않음!                                | dp = 한번 오른쪽/아래쪽 으로 가면 다시 올라갈 수 없음 = 문제가 점점 작아진다.            |
| 6  | 24.07.25 | [BOJ 11060](https://www.acmicpc.net/problem/11060) | `dp[i] = arr[i] 까지 오는데 걸리는 최소 점프 수`                                    |                                                    | 바텀업 : 0부터 시작해서 for문, 탑다운 : n(맨끝)부터 시작해서 재귀                  |
| 7  | 24.07.25 | [BOJ 15486](https://www.acmicpc.net/problem/15486) | i = 0 ~ n-1 을 돌며, i번째 상담을 하는 경우 & 하지 않는 경우를 고려                         | input 개수가 많기 때문에 시간복잡도가 O(n<sup>2</sup>) 이상이면 안된다! | [파이썬  빠른입출력 필수!!](https://www.acmicpc.net/board/view/22716) | ✅ |



- DP 개념 설명 : https://www.youtube.com/watch?v=5Lu34WIx2Us&t=2120s
- DP문제 추천 : https://stonejjun.tistory.com/24
