# 4️⃣ 구조 구성 / 연결성 판별 알고리즘

| 알고리즘                          | 언제 사용하는가?                                           | 핵심 역할 / 판단 기준                         |
|-------------------------------|-----------------------------------------------------|---------------------------------------|
| **유니온 파인드 (Disjoint Set)**        | **서로 연결되어 있는가?** 같은 그룹인가? (그래프 연결성 확인, 사이클 여부 판별 등) | - 연결 여부 확인<br>- 사이클 판별<br>- 서로소 집합 유지 |
| **MST (최소 신장 트리)<br>→ 크루스칼 / 프림** | **모든 노드를 최소 비용으로 연결하려면?** (전체 네트워크 구성, 비용 최적화)      | - 최소 비용 연결<br>- 전체를 하나의 그래프로 만들기      |
| **위상정렬 (Topological Sort)**       | **선후 관계가 있는 작업을 순서대로 할 수 있는가?** (의존성 순서, 사이클 유무 판단) | - 작업 순서 정하기<br>- 순서대로 정렬 가능 여부 판별     |
| **이분 매칭 (Bipartite Matching)**    | **두 그룹 간 최적 매칭을 어떻게 할까?** (할당, 짝짓기 문제 등)            | - 최대로 연결할 수 있는 쌍의 수 찾기<br>- 할당 최적화    |

## 📘 각 알고리즘별 설명 & 시점

### 1. 유니온 파인드 (Disjoint Set)
> “이 둘이 연결되어 있는가?”, “같은 그룹인가?”, “사이클이 생겼나?”
> 
-  언제 쓰나?
  - 무방향 그래프에서 사이클 유무 확인
  - 여러 노드를 같은 그룹으로 묶을 때
  - 네트워크 연결 여부 판단
- 사용 시점
  - 연결 여부를 여러 번 확인하거나, 집합을 합칠 때 (ex: 친구 관계, 네트워크, 사이클 검사)


### 2. MST (Minimum Spanning Tree)
> “모든 노드를 최소 비용으로 연결하려면?”
> 
- 언제 쓰나? 
  - 모든 노드를 한 트리로 연결하고 싶을 때 
  - 가중치(비용)를 최소화하고 싶을 때 
- 사용 시점
  - 도로, 전선, 통신망 등 전체 연결망을 구성할 때
  - 크루스칼은 간선 중심 / 프림은 노드 중심


### 3. 위상정렬
> “작업을 순서대로 진행할 수 있는가?”, “사이클이 있는가?”
> 
- 언제 쓰나?
  - 작업 간 **의존성(선후 관계)** 이 존재할 때
  - 순서를 지켜야 하는 경우 (예: 과목 수강, 프로젝트 단계)
- 사용 시점
  - 순서를 정할 수 있는지 판단하거나
  - 해당 순서대로 값을 누적하고 싶을 때 (DP와 자주 결합)

### 4. 이분 매칭 (Bipartite Matching)
> “두 집단 간 매칭을 최대로 하려면?”
>
- 언제 쓰나?
  - A그룹과 B그룹 간 짝짓기 문제 (예: 사람-일, 강의실-수업, 직원-업무 배정 등)
- 사용 시점
  - 최대 매칭 수를 구해야 할 때
  - 서로 중복 없이 짝지어야 할 때

---

## 위상 정렬 (topology sort)
> 방향 그래프의 모든 노드를 방향성을 지키며 순서대로 나열하는 알고리즘
- 특정 노드 간의 순서가 정해져있을 때 사용
- 사이클이 있는 경우 위상정렬을 수행할 수 없다.
- 위상정렬은 진입 차수(indegree)가 0인 노드부터 순차적으로 처리한다.

    만약 사이클이 존재한다면, 그 안에 진입차수가 0인 노드가 존재할 수 없다. 이로 인해 사이클에 포함된 노드들은 q에 들어가지 못한다.

    `while q:` 탐색을 하며 탐색 노드의 수를 카운트하고, 탐색한 노드의 수가 v개가 맞는지 확인하기!!!

## 우선순위 큐 (priority queue)

### 구현방법 1 - heapq 모듈

별도의 큐 클래스를 제공하는 것이 아니라, 리스트를 최소 힙으로 유지하면서 사용하는 방법

- 삽입 : `heapq.heappush` → O(log n)
- 최솟값(루트노드) 추출 : `heapq.heappop` → O(log n)
- 힙 생성 : `heapq.heapify` → O(n)

### 구현방법 2 - queue.PriorityQueue 클래스

내부적으로 heapq를 사용하여 우선순위 큐를 구현한다.

thread-safe를 보장하기 위해 추가적인 lock 메커니즘이 포함되어 있다. (**단일 스레드 환경에서는 오버헤드가 생길 수 있다.**)

- 삽입 : `put` → O(log n) .. 내부적으로 `heapq.heappush`를 호출
- 최솟값(루트노드) 추출 : `get` → O(log n) .. 내부적으로 `heapq.heappop`를 호출

## 최소 신장 트리 (MST, Minimum spanning tree)

- 문제에서 '필요 없는 간선을 모두 제거하자' 라는 말이 나오면 이 유형의 알고리즘이다!

🚨 주의할 점 🚨

- 최소 비용 신장 트리에서 **간선의 수는 항상 (노드의 수 - 1)** 이어야 한다.
- 사이클이 형성되면 안된다!

### 1. [크루스칼 알고리즘](https://www.youtube.com/watch?v=LQ3JHknGy8c)

#### 풀이 방법 `O(lonE)`

1. 간선을 가중치가 작은 순서대로 우선순위 큐에 저장
2. 간선이 작은 순서대로 하나씩 꺼내서 사이클 테이블을 반드시 확인해야 한다!
3. 사이클이 형성되지 않는 경우에만 그래프에 포함시킨다.
4. 간선의 개수가 v+1 개가 되면 반복문을 종료한다.

- 사이클 확인하는 방법 : 유니온 파인드

### 2. 프림 알고리즘

## [유니온 파인드 (union-find)](https://www.youtube.com/watch?v=AMByrd53PHM&t=396s)

- = 합집합 찾기 = 서로소 집합 알고리즘
- 여러 개의 노드가 존재할 때 2개의 노드를 선택해서 현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘
- 사이클이 발생하는지 확인하는 과정에서 find를 해주고, 사이클이 발생하지 않으면 그래프에 포함시키는 union을 해주면 된다.
- strongly connected component 등의 알고리즘에서도 사용된다.

#### 풀이 방법

1. 1차원 리스트(`arr`)를 사용해서 사이클 테이블을 초기화 시킨다. 리스트에는 각 노드의 부모 노드가 저장되는데, 처음 초기화 할 때에는 **자기 자신**을 가리키도록 한다.
2. (v1, v2) 두 노드를 연결할 때, `arr[v1]`, `arr[v2]` 중 더 작은 수를 가리키도록 한다.

   = 부모를 합칠 때에는 일반적으로 더 작은 값 쪽으로 합친다.
3. 이 때 멀리 떨어진 노드 중 연결되었다는 것을 표현하기 위해서 **재귀 함수** 사용
4. 만약 `arr[v1] == arr[v2]` 라면, 둘은 이미 한 그래프로 이어져 있다는 의미이다. (여기서 노드를 더 추가하면 사이클이 만들어진다.)