## [유니온 파인드 (union-find)](https://www.youtube.com/watch?v=AMByrd53PHM&t=396s)

- = 합집합 찾기 = 서로소 집합 알고리즘
- 여러 개의 노드가 존재할 때 2개의 노드를 선택해서 현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘
- 사이클이 발생하는지 확인하는 과정에서 find를 해주고, 사이클이 발생하지 않으면 그래프에 포함시키는 union을 해주면 된다.
- strongly connected component 등의 알고리즘에서도 사용된다.

#### 풀이 방법

1. 그래프의 모든 노드가 서로 자유분방하게 존재한다 가정하고 초기화한다. 즉, 모두 연결 되지 않고 각자 자기 자신만을 집합의 원소로 가지고 있는 것이다.
   
   그래프는 사이클 테이블을 통해서 표현한다. 이 테이블 (리스트)에는 각 노드가 자신의 부모 노드를 저장한다.
   
   처음 초기화 할 때에는 모든 노드가 **자기 자신**을 가리키도록 한다.
    - 그래프 0번째 행 : 노드의 번호
    - 그래프 1번째 행 : 부모 노드의 번호 (자신이 어떠한 부모에 포함되어 있는가를 나타냄. 가장 작은 번호를 )
   
   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
   |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
   
   
2. (1, 2) 두 노드를 연결할 때 = 부모를 합칠 때 일반적으로 더 작은 값 쪽으로 합친다.
   
   `1` < `2` 이니까
   - arr[1] = 1 로 그대로 두고
   - arr[2] = 1 로 바꿔준다.
   
   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
   |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
   | 1 | 1 | 3 | 4 | 5 | 6 | 7 | 8 |
   
   
2. (2, 3) 두 노드가 연결되었으면
   `2` < `3` 이니까
   - arr[2] = 1 로 그대로 두고
   - arr[3] = 2 로 바꿔준다.
   
   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
   |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
   | 1 | 1 | 2 | 4 | 5 | 6 | 7 | 8 |
   
   💥 1과 3은 같은 그래프여도 부모 노드가 다르다. 그래서 부모 노드만 보고 같은 그래프인지 한번에 파악할 수 없다.

3. 멀리 떨어진 노드도 한 그래프로 연결된 것을 확인하기 위해서 **재귀 함수** 사용

   1. (2, 3) 을 연결했고, 그 중 더 작은 값인 2를 arr[3]으로 넣어줌
   2. arr[2]에 재귀함수를 통해 접근하여 2가 가리키고 있는 부모노드를 확인한다.
   3. 만약, 자기자신인 2가 아니라 더 작은 수이면, 거기서 또 재귀를 해서 그 노드의 부모 노드를 찾아간다.
      
      재귀함수 종료 조건 : `arr[n] == n`
   
   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
   |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
   | 1 | 1 | 1 | 4 | 5 | 6 | 7 | 8 |

4. 만약 `arr[v1] == arr[v2]` 라면, 둘은 이미 한 그래프로 이어져 있다는 의미이다. (여기서 노드를 더 추가하면 사이클이 만들어진다.)
