# 그래프 이론

## 위상 정렬 (topology sort)
: 방향 그래프의 모든 노드를 방향성을 지키며 순서대로 나열하는 알고리즘
- 특정 노드 간의 순서가 정해져있을 때 사용

## 우선순위 큐 (priority queue)

### 구현방법 1 - heapq 모듈

별도의 큐 클래스를 제공하는 것이 아니라, 리스트를 최소 힙으로 유지하면서 사용하는 방법

- 삽입 : `heapq.heappush` → O(log n)
- 최솟값(루트노드) 추출 : `heapq.heappop` → O(log n)
- 힙 생성 : `heapq.heapify` → O(n)

### 구현방법 2 - queue.PriorityQueue 클래스

내부적으로 heapq를 사용하여 우선순위 큐를 구현한다.

thread-safe를 보장하기 위해 추가적인 lock 메커니즘이 포함되어 있다. (**단일 스레드 환경에서는 오버헤드가 생길 수 있다.**)

- 삽입 : `put` → O(log n) .. 내부적으로 `heapq.heappush`를 호출
- 최솟값(루트노드) 추출 : `get` → O(log n) .. 내부적으로 `heapq.heappop`를 호출

## [그래프 최단 경로 알고리즘](https://www.youtube.com/watch?v=acqm9mM1P6o)
: 출발 노드에서 도착 노드까지의 최소 비용을 구하는 알고리즘
- 다양한 문제 상황
- 한 지점에서 다른 한 지점까지의 최단 경로
- 한 지점에서 다른 모든 지점까지의 최단 경로
- 모든 지점에서 다른 모든 지점까지의 최단 경로

### 1. 다익스트라 알고리즘

- 한 노드에서 다른 모든 노드로 가는 최단 경로를 계산하는 알고리즘
- 음의 간선이 없을 때 정상 동작한다.

#### 탐색 과정

1. 출발 노드를 설정한다.
2. 최단 거리 테이블을 초기화한다. (1차원 배열. 출발 노드에서 모든 노드까지 가는데 드는 최소 비용을 저장하는 리스트)
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산해 최단 거리 테이블을 업데이트한다.
5. 3~4번 과정을 반복한다.
6. 다익스트라 알고리즘을 수행한 뒤에는 최단 거리 테이블에 시작 노드 ~ 각 노드 까지의 최단 거리 정보가 저장된다.

- 구현 방법
    1. 2차원 배열을 통한 순차 탐색 **O(N<sup>2</sup>)**
    2. 우선순위 큐 **O(E logV)**

### 2. 벨만-포드 알고리즘

- **음수 간선이 포함**된 상황에서의 최단 거리 문제

### 3. 플로이드-워셜 알고리즘

- 모든 노드에서 다른 모든 노드까지의 최단 거리 문제
- 다익스트라 알고리즘과 마찬가지로 단계별로 거쳐 가는 노드를 기준으로 알고리즘을 수행한다. (+ 매 단계마다 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾는 과정은 필요하지 X )
- 2차원 테이블에 최단 거리 정보를 저장. -> DP

## 최소 신장 트리 (MST, Minimum spanning tree)

- 문제에서 '필요 없는 간선을 모두 제거하자' 라는 말이 나오면 이 유형의 알고리즘이다!

🚨 주의할 점 🚨

- 최소 비용 신장 트리에서 **간선의 수는 항상 (노드의 수 - 1)** 이어야 한다.
- 사이클이 형성되면 안된다!

### 1. [크루스칼 알고리즘](https://www.youtube.com/watch?v=LQ3JHknGy8c)

#### 풀이 방법 `O(lonE)`

1. 간선을 가중치가 작은 순서대로 우선순위 큐에 저장
2. 간선이 작은 순서대로 하나씩 꺼내서 사이클 테이블을 반드시 확인해야 한다!
3. 사이클이 형성되지 않는 경우에만 그래프에 포함시킨다.
4. 간선의 개수가 v+1 개가 되면 반복문을 종료한다.

- 사이클 확인하는 방법 : 유니온 파인드

### 2. 프림 알고리즘

## [유니온 파인드 (union-find)](https://www.youtube.com/watch?v=AMByrd53PHM&t=396s)

- = 합집합 찾기 = 서로소 집합 알고리즘
- 여러 개의 노드가 존재할 때 2개의 노드를 선택해서 현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘
- 사이클이 발생하는지 확인하는 과정에서 find를 해주고, 사이클이 발생하지 않으면 그래프에 포함시키는 union을 해주면 된다.
- strongly connected component 등의 알고리즘에서도 사용된다.

#### 풀이 방법

1. 1차원 리스트(`arr`)를 사용해서 사이클 테이블을 초기화 시킨다. 리스트에는 각 노드의 부모 노드가 저장되는데, 처음 초기화 할 때에는 **자기 자신**을 가리키도록 한다.
2. (v1, v2) 두 노드를 연결할 때, `arr[v1]`, `arr[v2]` 중 더 작은 수를 가리키도록 한다.

   = 부모를 합칠 때에는 일반적으로 더 작은 값 쪽으로 합친다.
3. 이 때 멀리 떨어진 노드 중 연결되었다는 것을 표현하기 위해서 **재귀 함수** 사용
4. 만약 `arr[v1] == arr[v2]` 라면, 둘은 이미 한 그래프로 이어져 있다는 의미이다. (여기서 노드를 더 추가하면 사이클이 만들어진다.)

## 문제 풀이

| 번호 |    날짜    | 문제 번호                                              | 풀이법                                                                             | 주의사항                                                                                                                                       | 새롭게 배운 내용                                                                                                                        | 다시 풀어보기 |
|:--:|:--------:|:---------------------------------------------------|:--------------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------|:-------:|
| 1  | 24.09.18 | [BOJ 1766](https://www.acmicpc.net/problem/1766)   | [위상정렬] 우선 풀어야 하는 문제들을 먼저 풀어야 하므로 위상정렬 사용, 그 중에서 가장 작은 숫자를 먼저 출력해야 하므로 우선순위 큐 사용 |                                                                                                                                            |                                                                                                                                  |         |
| 2  | 24.09.19 | [BOJ 2252](https://www.acmicpc.net/problem/2252)   | [위상정렬] 각 노드의 진입차수를 저장하는 리스트 `in_degree`, 각 노드가 가리키는 노드를 저장하는 리스트 `graph` 를 분리   |                                                                                                                                            |                                                                                                                                  |         |
| 3  | 24.09.19 | [BOJ 1753](https://www.acmicpc.net/problem/1753)   | [다익스트라] 그래프에서의 최소 비용 구하는 문제!                                                    | 처음에 queue를 써서 구현했는데 시간초과가 발생해서 heapq로 변경함                                                                                                  |                                                                                                                                  |         |
| 4  | 24.09.21 | [BOJ 1916](https://www.acmicpc.net/problem/1916)   | [다익스트라] 방향+가중치 그래프에서 start에서 end로 가는 데 필요한 최소비용을 구해보자!                          | 한 노드에 대해 여러 종류의 비용이 존재할 수 있다! 입력을 받을 때, min으로 비교하며 최소값만 남겨야됨                                                                               |                                                                                                                                  |         |
| 5  | 24.09.22 | [BOJ 16118](https://www.acmicpc.net/problem/16118) | [다익스트라] 늑대의 경우 2가지 방법(빠름/느림)으로 노드에 도착할 수 있으므로 비용을 2차원 배열로 나눠서 저장해줌              | [시간초과 극복 방법](https://www.acmicpc.net/board/view/150147)                                                                                    | 인접 행렬(2차원 배열)보다 인접 리스트가 더 빠르다, 힙에 배열을 저장하는 방법                                                                                    |         |
| 6  | 24.09.23 | [BOJ 1261](https://www.acmicpc.net/problem/1261)   | [bfs] 2차원 배열에서의 최단 경로를 구하는 문제 -> bfs 사용                                         |                                                                                                                                            |                                                                                                                                  |         |
| 7  | 24.09.24 | [BOJ 11779](https://www.acmicpc.net/problem/11779) | [다익스트라] 최단 경로를 찾고, 그 경로까지 기억해야하는 문제                                             | **🚨주의🚨 시간초과를 피하기 위해서는 힙에서 꺼낸 값을 중복 방문하지 않게 조건문을 추가해야 한다!!**                                                                              | `arr.reverse()` : arr 리스트의 순서를 바꿔줌. <br>`print(' '.join(map(str, arr)))` : 이제 join에 익숙해질 때가 되지 않았니..                             |         |
| 8  | 24.09.25 | [BOJ 2307](https://www.acmicpc.net/problem/2307)   | [다익스트라] 다익스트라로 최단경로의 비용과 경로를 구해야 한다.                                            | 파이썬 때문인지 내 알고리즘 때문인지.. 시간초과 해결이 너무 힘들다ㅠㅠ [[오답노트]](https://velog.io/@sssunnny/Algorithm-2307%EB%B2%88-%EB%8F%84%EB%A1%9C%EA%B2%80%EB%AC%B8) | 다익스트라 알고리즘에서는 주로 연결된 노드만 탐색하기 때문에 인접 리스트가 더 효율적이다.                                                                               |    ✅    |
| 9  | 24.09.26 | [BOJ 4485](https://www.acmicpc.net/problem/4485)   | [bfs] 2차원 배열에서 bfs를 통해 최소합을 구하는 쉬운 문제!                                          |                                                                                                                                            |                                                                                                                                  |         |
| 10 | 24.09.28 | [BOJ 1238](https://www.acmicpc.net/problem/1238)   | [다익스트라] 모든 곳에서 end 까지의 최단경로 & end에서 모든 곳 까지의 최단경로를 모두 구하는 문제                    |                                                                                                                                            | 한 노드에서 다른 모든 노드로 가는 최단 경로를 계산하는 다익스트라 알고리즘으로도 이런 문제를 풀 수 있구나! 하지만 모든 노드에서 end 까지 가는 경로를 계산할 때에는 '노드의 개수' 만큼 다익스트라 알고리즘을 수행해야 한다. |         |
| 11 | 24.09.29 | [BOJ 2665](https://www.acmicpc.net/problem/2665)   | [bfs] 2차원 배열 미로에서 최단경로 구할 때에는 바로 bfs!!!                                         |                                                                                                                                            | 띄어쓰기 없는 정수의 나열을 하나의 정수 리스트로 저장하는 방법 : `list(map(int, input().strip()))`                                                          |         |
| 12 | 24.10.01 | [BOJ 1445](https://www.acmicpc.net/problem/1445)   | [bfs] 힙을 사용해서 bfs를 풀어야 시간초과 방지 가능                                               | 2개를 고려해야 해서 어려움. 1-쓰레기를 통과하는 횟수가 최소가 되는 경로 / 2- **그 중에서** 쓰레기를 지나는 횟수가 최소가 되는 경우                                                           | '쓰레기를 지난다.' 는 조건이 까다로움. 문제를 잘 읽자!!!                                                                                              |    ✅    |
| 13 | 24.10.02 | [BOJ 1197](https://www.acmicpc.net/problem/1197)   | [MST] 유니온 파인드와 크루스칼 알고리즘을 통해 최소 비용 신장 트리(MST)를 구하는 문제!                          | 유니온 파인드에서 재귀를 사용하기 때문에 `sys.setrecursionlimit(10**6)` 을 추가해야 한다!                                                                           | 유니온 파인드 알고리즘의 최적화 기법인 **경로 압축**에 대해서 더 공부하자!!                                                                                    |         |
| 14 | 24.10.03 | [BOJ 1922](https://www.acmicpc.net/problem/1922)   | [MST] 유니온 파인드와 크루스칼 알고리즘을 통해 최소 비용 신장 트리(MST)를 구하는 문제~                          | 유니온 파인드에서 두 노드를 이을 때에는 자신의 cycle 테이블이 아닌, 부모의 cycle 테이블을 갱신해야 한다!!!                                                                        | 유니온 파인드를 통해 사이클 없는 트리를 들기 위해선 3개의 함수를 구현해야 한다. (`get_parent`, `same_parent`, `union_parent`)                                     |         |
| 15 | 24.10.03 | [BOJ 1647](https://www.acmicpc.net/problem/1647)   | [MST] ,,                                                                        | 두 마을을 분리하는 문제 -> 만약 집(노드)이 2개밖에 없을 때에는 간선을 아예 안 그려야한다.                                                                                     |                                                                                                                                  |         |
